package lesson2

import "fmt"

/**
 * Циклы позволяют в зависимости от определенного условия выполнять некоторые действия множество раз.
 * Стандартно for для цикла
 */

func formain() {
	// for [инициализация счетчика]; [условие]; [изменение счетчика]{
	// 	   {действия}
	// }

	// Например, выведем с помощью цикла квадраты чисел:
	for i := 1; i < 10; i++ {
		fmt.Println(i * i)
	}

	// Нам необязательно указывать все условия при объявлении цикла. Например, можно вынести объявление переменной вовне
	var i = 1
	for ; i < 10; i++ {
		fmt.Println(i * i)
	}

	// Можно убрать изменение счетчика в само тело цикла и оставить только условие
	i = 1
	for i < 10 {
		fmt.Println(i * i)
		i++
	}

	// Бесконечный цикл, пока не встретит break
	i = 0
	for true {
		i++
		fmt.Println(i * i)
		if i > 2 {
			break // break полностью осуществляет выход из цикла
		}
	}
	//=========================================================================================================

	// Для перебора массивов можно использовать следующую форму цикла for:

	// for [индекс], [значение] := range массив {
	//     {действия}
	// }

	var users = [3]string{"Tom", "Alice", "Kate"}
	for index, value := range users {
		fmt.Println(index, value)
	}

	// Если мы не планируем использовать значения или индексы элементов, то мы можем вместо них указать прочерк.
	for _, value := range users { // Не нужен индекс
		fmt.Println(value)
	}

	// Может возникнуть ситуация, когда нам надо при определенных условиях завершить текущую итерацию цикла, не выполнять все инструкции цикла
	var numbers = [10]int{1, -2, 3, -4, 5, -6, -7, 8, -9, 10}
	var sum = 0

	for _, value := range numbers {
		if value < 0 {
			continue // переходим к следующей итерации
		}
		sum += value
	}
	fmt.Println("Sum:", sum) // Sum: 27
}
